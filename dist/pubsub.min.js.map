{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///pubsub.min.js","webpack:///webpack/bootstrap 1b4241ade3c5b2f14691","webpack:///./src/pubsub.js","webpack:///./src/alias.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_alias","_alias2","PubSub","topics","subUid","topic","callback","once","token","push","subscribe","data","that","setTimeout","subscribers","len","currentSubscriber","name","unsubscribe","tf","prop","hasOwnProperty","splice","on","trigger","off","alias","fn","_len","arguments","args","Array","_key","apply"],"mappings":"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","file":"pubsub.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PubSub\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PubSub\"] = factory();\n\telse\n\t\troot[\"PubSub\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * PubSub - Javascript implementation of the Publish/Subscribe pattern.\n * \n * @version v2.1.0\n * @author George Raptis <georapbox@gmail.com> (georapbox.github.io)\n * @homepage https://github.com/georapbox/PubSub#readme\n * @repository git+https://github.com:georapbox/PubSub.git\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PubSub\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PubSub\"] = factory();\n\telse\n\t\troot[\"PubSub\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _alias = __webpack_require__(1);\n\t\n\tvar _alias2 = _interopRequireDefault(_alias);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar PubSub = function () {\n\t  function PubSub() {\n\t    _classCallCheck(this, PubSub);\n\t\n\t    this.topics = {}; // Storage for topics that can be broadcast or listened to.\n\t    this.subUid = -1; // A topic identifier.\n\t  }\n\t\n\t  /**\n\t   * Subscribe to events of interest with a specific topic name and a\n\t   * callback function, to be executed when the topic/event is observed.\n\t   *\n\t   * @this {PubSub}\n\t   * @param {String} topic The topic name.\n\t   * @param {Function} callback Callback function to execute on event, taking two arguments:\n\t   *        - {*} data The data passed when publishing an event\n\t   *        - {Object} The topic's info (name & token)\n\t   * @param {Boolean} [once=false] Checks if event will be triggered only one time.\n\t   * @return {Number} The topic's token.\n\t   * @example\n\t   *\n\t   * var pubsub = new PubSub();\n\t   *\n\t   * var onUserAdd = pubsub.subscribe('user_add', function (data, topic) {\n\t   *   console.log('User added');\n\t   *   console.log('user data:', data);\n\t   * });\n\t   */\n\t\n\t\n\t  _createClass(PubSub, [{\n\t    key: 'subscribe',\n\t    value: function subscribe(topic, callback, once) {\n\t      var token = this.subUid += 1;\n\t      var obj = {};\n\t\n\t      if (typeof callback !== 'function') {\n\t        throw new TypeError('When subscribing for an event, a callback function must be defined.');\n\t      }\n\t\n\t      if (!this.topics[topic]) {\n\t        this.topics[topic] = [];\n\t      }\n\t\n\t      obj.token = token;\n\t      obj.callback = callback;\n\t      obj.once = !!once;\n\t\n\t      this.topics[topic].push(obj);\n\t\n\t      return token;\n\t    }\n\t\n\t    /**\n\t     * Subscribe to events of interest setting a flag\n\t     * indicating the event will be published only one time.\n\t     *\n\t     * @this {PubSub}\n\t     * @param {String} topic The topic's name.\n\t     * @param {Function} callback Callback function to execute on event, taking two arguments:\n\t     *        - {*} data The data passed when publishing an event\n\t     *        - {Object} The topic's info (name & token)\n\t     * @return {Number} The topic's token.\n\t     * @example\n\t     *\n\t     * var onUserAdd = pubsub.subscribeOnce('user_add', function (data, topic) {\n\t     *   console.log('User added');\n\t     *   console.log('user data:', data);\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribeOnce',\n\t    value: function subscribeOnce(topic, callback) {\n\t      return this.subscribe(topic, callback, true);\n\t    }\n\t\n\t    /**\n\t     * Publish or broadcast events of interest with a specific\n\t     * topic name and arguments such as the data to pass along.\n\t     *\n\t     * @this {PubSub}\n\t     * @param {String} topic The topic's name.\n\t     * @param {*} [data] The data to be passed.\n\t     * @return {Boolean} `true` if topic exists and event is published, else `false`.\n\t     * @example\n\t     *\n\t     * pubsub.publish('user_add', {\n\t     *   firstName: 'John',\n\t     *   lastName: 'Doe',\n\t     *   email: 'johndoe@gmail.com'\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(topic, data) {\n\t      var that = this;\n\t\n\t      if (!this.topics[topic]) {\n\t        return false;\n\t      }\n\t\n\t      setTimeout(function () {\n\t        var subscribers = that.topics[topic];\n\t        var len = subscribers ? subscribers.length : 0;\n\t\n\t        while (len) {\n\t          len -= 1;\n\t\n\t          var token = subscribers[len].token;\n\t          var currentSubscriber = subscribers[len];\n\t\n\t          currentSubscriber.callback(data, {\n\t            name: topic,\n\t            token: token\n\t          });\n\t\n\t          // Unsubscribe from event based on tokenized reference,\n\t          // if subscriber's property once is set to true.\n\t          if (currentSubscriber.once === true) {\n\t            that.unsubscribe(token);\n\t          }\n\t        }\n\t      }, 0);\n\t\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Unsubscribe from a specific topic, based on the topic name,\n\t     * or based on a tokenized reference to the subscription.\n\t     *\n\t     * @this {PubSub}\n\t     * @param {String|Object} topic Topic's name or subscription referenece.\n\t     * @return {Boolean|String} `false` if `topic` does not match a subscribed event, else the topic's name.\n\t     *\n\t     * PubSub.unsubscribe('user_add');\n\t     * or\n\t     * pubsub.unsubscribe(onUserAdd);\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(topic) {\n\t      var tf = false;\n\t\n\t      for (var prop in this.topics) {\n\t        if (Object.hasOwnProperty.call(this.topics, prop)) {\n\t          if (this.topics[prop]) {\n\t            var len = this.topics[prop].length;\n\t\n\t            while (len) {\n\t              len -= 1;\n\t\n\t              // `topic` is a tokenized reference to the subscription.\n\t              if (this.topics[prop][len].token === topic) {\n\t                this.topics[prop].splice(len, 1);\n\t                return topic;\n\t              }\n\t\n\t              // `topic` is the event name.\n\t              if (prop === topic) {\n\t                this.topics[prop].splice(len, 1);\n\t                tf = true;\n\t              }\n\t            }\n\t\n\t            if (tf === true) {\n\t              return topic;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return false;\n\t    }\n\t  }]);\n\t\n\t  return PubSub;\n\t}();\n\t\n\t// Alias for public methods.\n\t\n\t\n\tPubSub.prototype.on = (0, _alias2.default)('subscribe');\n\tPubSub.prototype.once = (0, _alias2.default)('subscribeOnce');\n\tPubSub.prototype.trigger = (0, _alias2.default)('publish');\n\tPubSub.prototype.off = (0, _alias2.default)('unsubscribe');\n\t\n\texports.default = PubSub;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Alias a method while keeping the context correct,\n\t * to allow for overwriting of target method.\n\t *\n\t * @private\n\t * @this {PubSub}\n\t * @param {String} fn The name of the target method.\n\t * @return {function} The aliased method.\n\t */\n\tfunction alias(fn) {\n\t  return function closure() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return this[fn].apply(this, args);\n\t  };\n\t}\n\t\n\texports.default = alias;\n\tmodule.exports = exports[\"default\"];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// pubsub.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1b4241ade3c5b2f14691","import alias from './alias';\n\nclass PubSub {\n  constructor() {\n    this.topics = {}; // Storage for topics that can be broadcast or listened to.\n    this.subUid = -1; // A topic identifier.\n  }\n\n  /**\n   * Subscribe to events of interest with a specific topic name and a\n   * callback function, to be executed when the topic/event is observed.\n   *\n   * @this {PubSub}\n   * @param {String} topic The topic name.\n   * @param {Function} callback Callback function to execute on event, taking two arguments:\n   *        - {*} data The data passed when publishing an event\n   *        - {Object} The topic's info (name & token)\n   * @param {Boolean} [once=false] Checks if event will be triggered only one time.\n   * @return {Number} The topic's token.\n   * @example\n   *\n   * var pubsub = new PubSub();\n   *\n   * var onUserAdd = pubsub.subscribe('user_add', function (data, topic) {\n   *   console.log('User added');\n   *   console.log('user data:', data);\n   * });\n   */\n  subscribe(topic, callback, once) {\n    const token = this.subUid += 1;\n    const obj = {};\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('When subscribing for an event, a callback function must be defined.');\n    }\n\n    if (!this.topics[topic]) {\n      this.topics[topic] = [];\n    }\n\n    obj.token = token;\n    obj.callback = callback;\n    obj.once = !!once;\n\n    this.topics[topic].push(obj);\n\n    return token;\n  }\n\n  /**\n   * Subscribe to events of interest setting a flag\n   * indicating the event will be published only one time.\n   *\n   * @this {PubSub}\n   * @param {String} topic The topic's name.\n   * @param {Function} callback Callback function to execute on event, taking two arguments:\n   *        - {*} data The data passed when publishing an event\n   *        - {Object} The topic's info (name & token)\n   * @return {Number} The topic's token.\n   * @example\n   *\n   * var onUserAdd = pubsub.subscribeOnce('user_add', function (data, topic) {\n   *   console.log('User added');\n   *   console.log('user data:', data);\n   * });\n   */\n  subscribeOnce(topic, callback) {\n    return this.subscribe(topic, callback, true);\n  }\n\n  /**\n   * Publish or broadcast events of interest with a specific\n   * topic name and arguments such as the data to pass along.\n   *\n   * @this {PubSub}\n   * @param {String} topic The topic's name.\n   * @param {*} [data] The data to be passed.\n   * @return {Boolean} `true` if topic exists and event is published, else `false`.\n   * @example\n   *\n   * pubsub.publish('user_add', {\n   *   firstName: 'John',\n   *   lastName: 'Doe',\n   *   email: 'johndoe@gmail.com'\n   * });\n   */\n  publish(topic, data) {\n    const that = this;\n\n    if (!this.topics[topic]) {\n      return false;\n    }\n\n    setTimeout(function () {\n      const subscribers = that.topics[topic];\n      let len = subscribers ? subscribers.length : 0;\n\n      while (len) {\n        len -= 1;\n\n        const token = subscribers[len].token;\n        const currentSubscriber = subscribers[len];\n\n        currentSubscriber.callback(data, {\n          name: topic,\n          token: token\n        });\n\n        // Unsubscribe from event based on tokenized reference,\n        // if subscriber's property once is set to true.\n        if (currentSubscriber.once === true) {\n          that.unsubscribe(token);\n        }\n      }\n    }, 0);\n\n    return true;\n  }\n\n  /**\n   * Unsubscribe from a specific topic, based on the topic name,\n   * or based on a tokenized reference to the subscription.\n   *\n   * @this {PubSub}\n   * @param {String|Object} topic Topic's name or subscription referenece.\n   * @return {Boolean|String} `false` if `topic` does not match a subscribed event, else the topic's name.\n   *\n   * PubSub.unsubscribe('user_add');\n   * or\n   * pubsub.unsubscribe(onUserAdd);\n   */\n  unsubscribe(topic) {\n    let tf = false;\n\n    for (let prop in this.topics) {\n      if (Object.hasOwnProperty.call(this.topics, prop)) {\n        if (this.topics[prop]) {\n          let len = this.topics[prop].length;\n\n          while (len) {\n            len -= 1;\n\n            // `topic` is a tokenized reference to the subscription.\n            if (this.topics[prop][len].token === topic) {\n              this.topics[prop].splice(len, 1);\n              return topic;\n            }\n\n            // `topic` is the event name.\n            if (prop === topic) {\n              this.topics[prop].splice(len, 1);\n              tf = true;\n            }\n          }\n\n          if (tf === true) {\n            return topic;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\n// Alias for public methods.\nPubSub.prototype.on = alias('subscribe');\nPubSub.prototype.once = alias('subscribeOnce');\nPubSub.prototype.trigger = alias('publish');\nPubSub.prototype.off = alias('unsubscribe');\n\nexport default PubSub;\n\n\n\n// WEBPACK FOOTER //\n// ./src/pubsub.js","/**\n * Alias a method while keeping the context correct,\n * to allow for overwriting of target method.\n *\n * @private\n * @this {PubSub}\n * @param {String} fn The name of the target method.\n * @return {function} The aliased method.\n */\nfunction alias(fn) {\n  return function closure(...args) {\n    return this[fn].apply(this, args);\n  };\n}\n\nexport default alias;\n\n\n\n// WEBPACK FOOTER //\n// ./src/alias.js"],"sourceRoot":""}